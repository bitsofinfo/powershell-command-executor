module.exports = PSCommandService;

var Promise = require('promise');
var Mustache = require('mustache');

/**
* PSCommandService
*
* @param statefulProcessCommandProxy all commands will be executed over this
* @param commandRegistry registry/hash of Powershell commands
*        @see o365CommandRegistry.js for examples
*
*/
function PSCommandService(statefulProcessCommandProxy,commandRegistry) {
    this._statefulProcessCommandProxy = statefulProcessCommandProxy;
    this._commandRegistry = commandRegistry;
}

/**
* executeForStdout()
*
* Executes a named powershell command as registered in the
* command registry, applying the values from the argument map
* returns a promise that when fulfilled returns the stdout
* from the command.
*
* On reject an error message
*
* @param array of commands
*/
PSCommandService.prototype.executeForStdout = function(commandName, argument2ValueMap) {
    return this._execute(commandName,argument2ValueMap).stdout;
}

/**
* execute()
*
* Executes a named powershell command as registered in the
* command registry, applying the values from the argument map
* returns a promise that when fulfilled returns the cmdResult
* object from the command which contains properties
* (command, stdout, stderr)
*
* On reject an error message
*
* @param array of commands
*/
PSCommandService.prototype.execute = function(commandName, argument2ValueMap) {
  var commandConfig = this._commandRegistry[commandName];
  var command = this._generateCommand(commandConfig, argument2ValueMap);
  return this._execute(command);
}



/**
* _execute()
*
* Executes one powershell command generated by _generateCommand(),
* returns a promise when fulfilled returns the cmdResult object from the command
* which contains 3 properties (command, stdout, stderr)
*
* On reject an error message
*
* @param array of commands
*/
PSCommandService.prototype._execute = function(command) {
  var self = this;

  console.log('#########################\nExecuting:\n'+command+'\n#########################');

  return new Promise(function(fulfill,reject) {
    self._executeCommands([command])
    .then(function(cmdResults) {
      fulfill(cmdResults[command]);
    }).catch(function(error) {
      reject('unexpected error getting executing command: ' + error + "\n" + error.stack);
    });
  });
}


/**
* _executeCommands()
*
* Executes one or more powershell commands generated by _generateCommand(),
* returns a promise when fulfilled returns an hash of results in the form:

* { <command> : {command: <command>, stdout: value, stderr: value }}
*
* On reject an error message
*
* @param array of commands
*/
PSCommandService.prototype._executeCommands = function(commands) {
    var self = this;

    return new Promise(function(fulfill,reject) {
        self._statefulProcessCommandProxy.executeCommands(commands)
        .then(function(cmdResults) {
            fulfill(cmdResults);
        }).catch(function(error) {
            reject('unexpected error getting executing commands: ' + error + "\n" + error.stack);
        });
    });
}

/**
* _generateCommand()
*
* @param commandConfig a command config object that the argumentMap will be applied to
* @param argument2ValueMap map of argument names -> values (valid for the passed commandConfig)
*
* @return a formatted powershell command string suitable for execution
*
* !!!! TODO: review  security protection for "injection" (i.e command termination, newlines etc)
*/
PSCommandService.prototype._generateCommand = function(commandConfig, argument2ValueMap) {

    var argumentsConfig = commandConfig.arguments;

    var argumentsString = "";

    for (var argumentName in argumentsConfig) {

        if(argumentsConfig.hasOwnProperty(argumentName)) {

            var argument = argumentsConfig[argumentName];

            // is argument valued
            if ((argument.hasOwnProperty('valued') ? argument.valued : true)) {

                var isQuoted = (argument.hasOwnProperty('quoted') ? argument.quoted : true);
                var passedArgValues = argument2ValueMap[argumentName];

                if (!(passedArgValues instanceof Array)) {

                    if (typeof passedArgValues === 'undefined') {

                        if (argument.hasOwnProperty('default')) {
                            passedArgValues = [argument.default];
                        } else {
                            passedArgValues = [];
                        }

                    } else {
                        passedArgValues = [passedArgValues];
                    }
                }

                var argumentValues = "";
                for (var i=0; i<passedArgValues.length; i++) {

                    var passedArgValue = passedArgValues[i];

                    var valueToSet;

                    if (passedArgValue && passedArgValue != 'undefined') {
                        valueToSet = passedArgValue;

                    } else if (argument.hasOwnProperty('default')) {
                        valueToSet = argument.default;
                    }

                    // append the value
                    if (valueToSet && valueToSet.trim().length > 0) {

                        // sanitize
                        valueToSet = this._sanitize(valueToSet);

                        // append w/ quotes (SINGLE QUOTES, not double to avoid expansion)
                        argumentValues += (this._finalizeParameterValue(valueToSet,isQuoted) + ",");
                    }
                }

                // were values appended?
                if (argumentValues.length > 0) {

                    // append to arg string
                    argumentsString += (("-"+argumentName+" ") + argumentValues);

                    if (argumentsString.lastIndexOf(',') == (argumentsString.length -1)) {
                        argumentsString = argumentsString.substring(0,argumentsString.length-1);
                    }
                    argumentsString += " ";
                }

                // argument is NOT valued, just append the name
            } else {
                argumentsString += ("-"+argumentName+" ");
            }

        }

    }

    return Mustache.render(commandConfig.command,{'arguments':argumentsString});
}

PSCommandService.prototype._finalizeParameterValue = function(valueToSet, applyQuotes) {
    valueToSet = ((applyQuotes?"'":'')+valueToSet+(applyQuotes?"'":''));

    return valueToSet;
}

PSCommandService.prototype._sanitize = function(toSanitize) {
    toSanitize.replace(/(\n)/g, "\\$1"); // escape newlines

    // escape stuff that could screw up variables, or break quoting
    return toSanitize.replace(/(['`#])/g, "`$1");
}
